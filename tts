#!/usr/bin/env python3
import time
import hashlib
import math
import sys
import os
import tempfile
import subprocess
import argparse
import io
import warnings
import threading
import pickle
import glob
import enum

import gtts
import pyperclip

# Removing bad substitution of M. to Monsieur
gtts.tokenizer.symbols.SUB_PAIRS = []
CACHE_WARNING_SIZE = 1e10  # 10 GB
CACHE_DIR = os.sep.join([os.getenv("HOME", None), ".cache", "tts"])
CACHE_FILENAME_PATTERN = "tts_cache_{}.pickle"


def human_filesize(bytes_):
    units = ["bytes", "kB", "MB", "GB", "TB", "PB"]
    power = 0
    for power, unit in enumerate(units):
        if bytes_ < 1024 ** (power + 1):
            break
    if power == 0:
        return "{} bytes".format(bytes_)
    return "{:.2f} {}".format(bytes_ / 1024.0 ** power, unit)


def add_arguments(parser):
    source_group = parser.add_mutually_exclusive_group()
    source_group.add_argument("-c", "--clipboard", action="store_true")
    source_group.add_argument(
        "-f",
        "--file",
        dest="infile",
        type=str,
        help='Input file of text to read. "-" for stdin.',
    )
    parser.add_argument("text", type=str, nargs="*")
    parser.add_argument("-l", "--loop", action="store_true")
    parser.add_argument("--no-cache", dest="cache", action="store_false")
    parser.add_argument("--clear-cache", action="store_true")

    return parser


class LineState(enum.Enum):
    r"""

    FREE --> DISPATCHED --> READY
                        \
                         -> ERROR
    """
    FREE = enum.auto()  # Nothing has been done with this line yet
    DISPATCHED = enum.auto()  # Line has been given to a worker thread
    READY = enum.auto()  # Line has been converted and is ready to read
    ERROR = enum.auto()  # Line conversion failed


class Line(object):
    def __eq__(self, other):
        return self.text == other.text

    def __init__(self, text):
        self.text = text.strip()
        self.state = LineState.FREE
        self.error = None
        self.mp3bytes = None

    def __hash__(self):
        return hash(self.text)

    def play(self):
        if self.state == LineState.READY:
            self.__play_gtts_mp3()
        elif self.state == LineState.ERROR:
            self.__play_espeak_fallback()
        else:
            raise RuntimeError(
                'Tried to play not ready line "{}" with state "{}"'.format(
                    self.text, self.state
                )
            )

    def __play_gtts_mp3(self):
        with open("/dev/null") as devnull:
            p = subprocess.Popen(
                ["play", "-t", "mp3", "-"], stderr=devnull, stdin=subprocess.PIPE
            )
            p.stdin.write(self.mp3bytes)
            p.stdin.close()
            p.wait()

    def __play_espeak_fallback(self):
        msg = (
            'Tried to play line "{}" with state "{}". The error was "{}". '
            "Falling back to espeak."
        )
        warnings.warn(msg.format(self.text, self.state, self.error))
        p = subprocess.Popen(["espeak"], stdin=subprocess.PIPE)
        p.stdin.write(self.text.encode())
        p.stdin.close()
        p.wait()

    def convert(self):
        try:
            tts = gtts.gTTS(self.text)
            data = io.BytesIO()
            tts.write_to_fp(data)
            data.seek(0)
            self.mp3bytes = data.getvalue()
            self.state = LineState.READY
        except Exception as e:
            self.error = e
            self.state = LineState.ERROR
            warnings.warn('Error "{}" when converting line "{}"'.format(e, self.text))


class Worker(object):
    def __init__(self, lines, thread_count=3, start_idx=0):
        self.__lines = lines
        self.__reader_idx = start_idx
        self.__lock = threading.Lock()
        self.__has_been_closed = False
        self.__t_producers = []
        for __ in range(thread_count):
            t = threading.Thread(target=self.__produce)
            self.__t_producers.append(t)

        for t in self.__t_producers:
            t.start()

    def close(self):
        if self.__has_been_closed:
            return
        self.__has_been_closed = True
        for t in self.__t_producers:
            t.join()
        self.__t_producers = []

    def __produce(self):
        for line in self:
            if self.__has_been_closed:
                return
            line.convert()

    def set_reader_index(self, idx):
        self.__lock.acquire()
        try:
            self.__reader_idx = idx
        finally:
            self.__lock.release()

    def __iter__(self):
        return self

    def __next__(self):
        return self.next()

    def next(self):
        self.__lock.acquire()
        try:
            line_order = (
                self.__lines[self.__reader_idx :] + self.__lines[: self.__reader_idx]
            )
        finally:
            self.__lock.release()
        for line in line_order:
            if line.state == LineState.FREE:
                line.state = LineState.DISPATCHED
                return line
        raise StopIteration

    def __del__(self):
        self.close()


def main(infile, loop, text, cache, clear_cache, clipboard):
    if infile:
        if infile == "-":
            all_text = sys.stdin.read()
        else:
            with open(infile) as f:
                all_text = f.read()
    elif clipboard:
        all_text = pyperclip.paste()
    else:
        all_text = " ".join(text)

    if os.path.exists(CACHE_DIR):
        glob_pattern = os.path.sep.join([CACHE_DIR, CACHE_FILENAME_PATTERN.format("*")])
        cache_paths = glob.glob(glob_pattern)
        if clear_cache:
            for path in cache_paths:
                os.remove(path)
        else:
            total_bytes = sum(os.path.getsize(path) for path in cache_paths)
            if total_bytes > CACHE_WARNING_SIZE:
                msg_fmt = (
                    'Total size of tts cache at path "{}" has size {}, exceeding '
                    "the warning limit of {}. Run tts --clear-cache to delete all "
                    "cached files."
                )
                msg = msg_fmt.format(
                    CACHE_DIR,
                    human_filesize(total_bytes),
                    human_filesize(CACHE_WARNING_SIZE),
                )
                warnings.warn(msg)

    lines = tuple(Line(l) for l in all_text.split("\n") if l.strip())

    if not lines:
        return 0

    if cache:
        # Shift into positive range
        hex_digits = 8
        stripped_text = "\n".join(l.text for l in lines)
        curr_hash = int(
            hashlib.md5(stripped_text.encode()).hexdigest()[:hex_digits], 16
        )
        hex_pattern = "{{:0{}x}}".format(hex_digits)
        while True:
            hex_hash = hex_pattern.format(curr_hash)
            cache_path = os.sep.join(
                [CACHE_DIR, CACHE_FILENAME_PATTERN.format(hex_hash)]
            )
            if os.path.exists(cache_path):
                with open(cache_path, "r+b") as f:
                    cached_lines = pickle.load(f)
                    if lines == cached_lines:
                        # Found existing match
                        lines = cached_lines
                        break
                    else:
                        # Hash collision
                        curr_hash += 1
            else:
                break

    reader_idx = 0
    loop = False
    worker = Worker(lines, start_idx=reader_idx)

    while True:
        line = lines[reader_idx]
        while line.state in [LineState.FREE, LineState.DISPATCHED]:
            time.sleep(0.1)
        if line.state in [LineState.READY, LineState.ERROR]:
            line.play()
        else:
            msg = 'Tried to play line "{}" w/ state "{}". This should never ' "happen."
            raise RuntimeError(msg.format(line.text, line.state))
        reader_idx += 1
        if reader_idx >= len(lines):
            if loop:
                reader_idx = reader_idx % len(lines)
            else:
                break
        worker.set_reader_index(reader_idx)

    worker.close()

    if cache:
        subprocess.call(["mkdir", "-p", CACHE_DIR])
        for line in lines:
            if line.state != LineState.READY:
                line.state = LineState.FREE
            line.error = None
        with open(cache_path, "w+b") as f:
            pickle.dump(lines, f)

    return 0


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="TTS program backed by Google TTS with an espeak fallback"
    )
    add_arguments(parser)
    args = parser.parse_args()
    if args.text and (args.infile or args.clipboard):
        parser.error("Arguments text, infile, and clipboard are mutually exclusive.")
    sys.exit(main(**args.__dict__))
