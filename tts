#!/usr/bin/env python3
import time
import hashlib
import math
import sys
import os
import tempfile
import subprocess
import argparse
import io
import warnings
import threading
import pickle
import glob

import gtts
import pyperclip

# Removing bad substitution of M. to Monsieur
gtts.tokenizer.symbols.SUB_PAIRS = []
CACHE_WARNING_SIZE = 1e10  # 10 GB
CACHE_DIR = os.sep.join([os.getenv("HOME", None), ".cache", "tts"])
CACHE_FILENAME_PATTERN = "tts_cache_{}.pickle"


def human_filesize(bytes_):
    units = ["bytes", "kB", "MB", "GB", "TB", "PB"]
    power = 0
    for power, unit in enumerate(units):
        if bytes_ < 1024 ** (power + 1):
            break
    if power == 0:
        return "{} bytes".format(bytes_)
    return "{:.2f} {}".format(bytes_ / 1024.0 ** power, unit)


def add_arguments(parser):
    source_group = parser.add_mutually_exclusive_group()
    source_group.add_argument("-c", "--clipboard", action="store_true")
    source_group.add_argument(
        "-f",
        "--file",
        dest="infile",
        type=str,
        help='Input file of text to read. "-" for stdin.',
    )
    parser.add_argument("text", type=str, nargs="*")
    parser.add_argument("-l", "--loop", action="store_true")
    parser.add_argument("--no-cache", dest="cache", action="store_false")
    parser.add_argument("--clear-cache", action="store_true")

    return parser

class LineStatus(enum.Enum):
    FREE = enum.auto()
    DISPATCHED = enum.auto()
    READY = enum.auto()
    ERROR = enum.auto()


class Line(object):
    def __eq__(self, other):
        return self.text == other.text

    def __init__(self, text):
        self.text = text.strip()
        self.status = LineStatus.FREE
        self.error = None
        self.mp3bytes = None

    def __hash__(self):
        return hash(self.text)

    def play(self):
        if self.status != LineStatus.READY:
            raise RuntimeError(
                'Tried to play not ready line "{}" with status "{}"'.format(
                    self.text, self.status
                )
            )
        with open("/dev/null") as devnull:
            p = subprocess.Popen(
                ["play", "-t", "mp3", "-"], stderr=devnull, stdin=subprocess.PIPE
            )
            p.stdin.write(self.mp3bytes)
            p.stdin.close()
            p.wait()

    def play_fallback(self):
        p = subprocess.Popen(["espeak"], stdin=subprocess.PIPE)
        p.stdin.write(self.text.encode())
        p.stdin.close()
        p.wait()

    def convert(self):
        try:
            tts = gtts.gTTS(self.text)
            data = io.BytesIO()
            tts.write_to_fp(data)
            data.seek(0)
            self.mp3bytes = data.getvalue()
            self.status = LineStatus.READY
        except Exception as e:
            self.error = e
            self.status = LineStatus.ERROR
            warnings.warn('Error "{}" when converting line "{}"'.format(e, self.text))


class Worker(object):
    def __init__(self, lines, thread_count=3, start_idx=0, loop=False):
        self.__lines = lines
        self.__reader_idx = start_idx
        self.__lock = threading.Lock()
        self.__has_been_closed = False
        self.__t_producers = []
        self.__loop = loop
        for __ in range(thread_count):
            t = threading.Thread(target=self.__produce)
            self.__t_producers.append(t)
        self.__t_consumer = threading.Thread(target=self.__consume)

        for t in self.__t_producers:
            t.start()
        self.__t_consumer.start()

    def block_until_done_reading(self):
        while self.__t_consumer.isAlive():
            time.sleep(0.1)

    def close(self):
        if self.__has_been_closed:
            return
        self.__has_been_closed = True
        for t in self.__t_producers:
            t.join()
        self.__t_producers = []
        self.__t_consumer.join()
        self.__t_consumer = None

    def __produce(self):
        for line in self:
            if self.__has_been_closed:
                return
            line.convert()

    def __consume(self):
        while True:
            if self.__has_been_closed:
                return
            line = self.__lines[self.__reader_idx]
            while line.status in [LineStatus.FREE, LineStatus.DISPATCHED]:
                if self.__has_been_closed:
                    return
                time.sleep(0.1)
            if line.status == LineStauts.READY:
                line.play()
            elif line.status == LineStatus.ERROR:
                msg = (
                    'Tried to play line "{}" with status "{}". The error was "{}". '
                    "Falling back to espeak."
                )
                warnings.warn(msg.format(line.text, line.status, line.error))
                line.play_fallback()
            else:
                msg = (
                    'Tried to play line "{}" w/ status "{}". This should never '
                    "happen."
                )
                raise RuntimeError(msg.format(line.text, line.status))
            self.__lock.acquire()
            try:
                self.__reader_idx += 1
                if self.__reader_idx >= len(self.__lines):
                    if self.__loop:
                        self.__reader_idx = self.__reader_idx % len(self.__lines)
                    else:
                        return
            finally:
                self.__lock.release()

    def set_reader_index(self, idx):
        self.__lock.acquire()
        try:
            self.__reader_idx = idx
        finally:
            self.__lock.release()

    def __iter__(self):
        return self

    def __next__(self):
        return self.next()

    def next(self):
        self.__lock.acquire()
        try:
            line_order = (
                self.__lines[self.__reader_idx :] + self.__lines[: self.__reader_idx]
            )
            for line in line_order:
                if line.status == LineStatus.FREE:
                    line.status = LineStatus.DISPATCHED
                    return line
            raise StopIteration
        finally:
            self.__lock.release()

    def __del__(self):
        self.close()


def main(infile, loop, text, cache, clear_cache, clipboard):
    if infile:
        if infile == "-":
            all_text = sys.stdin.read()
        else:
            with open(infile) as f:
                all_text = f.read()
    elif clipboard:
        all_text = pyperclip.paste()
    else:
        all_text = " ".join(text)

    if os.path.exists(CACHE_DIR):
        glob_pattern = os.path.sep.join([CACHE_DIR, CACHE_FILENAME_PATTERN.format("*")])
        cache_paths = glob.glob(glob_pattern)
        if clear_cache:
            for path in cache_paths:
                os.remove(path)
        else:
            total_bytes = sum(os.path.getsize(path) for path in cache_paths)
            if total_bytes > CACHE_WARNING_SIZE:
                msg_fmt = (
                    'Total size of tts cache at path "{}" has size {}, exceeding '
                    "the warning limit of {}. Run tts --clear-cache to delete all "
                    "cached files."
                )
                msg = msg_fmt.format(
                    CACHE_DIR,
                    human_filesize(total_bytes),
                    human_filesize(CACHE_WARNING_SIZE),
                )
                warnings.warn(msg)

    lines = tuple(Line(l) for l in all_text.split("\n") if l.strip())

    if not lines:
        return 0

    if cache:
        # Shift into positive range
        hex_digits = 8
        stripped_text = "\n".join(l.text for l in lines)
        curr_hash = int(
            hashlib.md5(stripped_text.encode()).hexdigest()[:hex_digits], 16
        )
        hex_pattern = "{{:0{}x}}".format(hex_digits)
        while True:
            hex_hash = hex_pattern.format(curr_hash)
            cache_path = os.sep.join(
                [CACHE_DIR, CACHE_FILENAME_PATTERN.format(hex_hash)]
            )
            if os.path.exists(cache_path):
                with open(cache_path, "r+b") as f:
                    cached_lines = pickle.load(f)
                    if lines == cached_lines:
                        # Found existing match
                        lines = cached_lines
                        break
                    else:
                        # Hash collision
                        curr_hash += 1
            else:
                break

    worker = Worker(lines, loop=loop)
    worker.block_until_done_reading()
    worker.close()
    if cache:
        subprocess.call(["mkdir", "-p", CACHE_DIR])
        for line in lines:
            if line.status != LineStatus.READY:
                line.status = LineStatus.FREE
            line.error = None
        with open(cache_path, "w+b") as f:
            pickle.dump(lines, f)

    return 0


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="TTS program backed by Google TTS with an espeak fallback"
    )
    add_arguments(parser)
    args = parser.parse_args()
    if args.text and (args.infile or args.clipboard):
        parser.error("Arguments text, infile, and clipboard are mutually exclusive.")
    sys.exit(main(**args.__dict__))
